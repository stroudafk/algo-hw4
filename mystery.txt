Q2
The best case scenario is the case that the pivot is equal to the value of the kth element of the sorted ascending array (0 indexed). The time complexity of this is O(n), where n is the number of elements in the input vector, because even in the best case we would have to loop through the entire contents of the array to ensure we have all the values smaller than or equal to the pivot in the proper array. 

{42, 13, 43, 14, 18, 66, 90, 68, 81, 96}
// p = 42
// k = 3
// {13 14 18} {42} {43 66 90 68 81 96}
// return 42



Q3
The worst case time complexity occurs when the pivot is farthest position wise from the target value, or if the array is already sorted in descending or ascending order depending on the target element/k. 

Since each iteration would be a new recursive call over a vector of size n-1, time complexity is O(n^2)

Q5
Where n is the size of the input, at the very least per recursive call, we would need O(n) space because we receive a copy of a vector that is potentially n-1 at the worst case, and then before the next recursive call, we create 3 vectors with the total allocated space of n. So worst case is about 2n + 1, which would simplify to O(n).


Q6
Mystery returns the k+1 smallest element.




// test 1 "A00000000"
// Your input array for Q1 is {38, 41, 47, 65, 4, 32, 49, 12, 59, 16}
// Your first row should be {38, 41, 47, 65, 4, 32, 49, 12, 59, 16, 5}
// pivot 38
// k = 5
// {4, 32, 12, 16}
// {38}
// {41, 47, 65, 49, 59}

// pivot = 41
// k = 0
// {}{41}{47, 65, 49, 59}

// return 41

//callsToMystery returns {{38, 41, 47, 65, 4, 32, 49, 12, 59, 16, 5}, {41,47,65,49,59,0}};

// test case 2
// "A00000100"
// Your input array for Q1 is {13, 42, 43, 14, 18, 66, 90, 68, 81, 96}

// p = 13
// k = 3
// {} {13} {42 43 14 18 66 90 68 81 96}
// mystery({42 43 14 18 66 90 68 81 96}, 2)

// p = 42
// k = 2

// {42 43 14 18 66 90 68 81 96}
// {14 18} {42} {43 66 90 81 96}
// return 42
